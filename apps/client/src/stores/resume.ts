import { t } from "@lingui/macro";
import { createId } from "@paralleldrive/cuid2";
import type { ResumeDto } from "@elevate/dto";
import type { CustomSectionGroup, SectionKey } from "@elevate/schema";
import { defaultSection } from "@elevate/schema";
import { removeItemInLayout } from "@elevate/utils";
import _set from "lodash.set";
import type { TemporalState } from "zundo";
import { temporal } from "zundo";
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { useStoreWithEqualityFn } from "zustand/traditional";

import { debouncedUpdateResume } from "../services/resume";

/**
 * Allowed value types for setValue
 * Since lodash.set doesn't preserve types, we accept common resume data types
 */
type ResumeValue = string | number | boolean | null | undefined | ResumeValue[] | Record<string, ResumeValue>;

type ResumeStore = {
  resume: ResumeDto;

  // Actions
  /**
   * Set a value at a nested path in the resume data structure
   * @param path - Dot-separated path (e.g., "metadata.notes", "sections.experience.items")
   * @param value - Value to set (string, number, boolean, array, object, or null)
   */
  setValue: (path: string, value: ResumeValue) => void;

  // Custom Section Actions
  addSection: () => void;
  removeSection: (sectionId: SectionKey) => void;

  // Section Collapsed/Expanded State
  collapsedSections: Record<string, boolean>;
  toggleCollapseSection: (id: string) => void;
  expandAllSections: () => void;
  collapseAllSections: () => void;
};

export const useResumeStore = create<ResumeStore>()(
  temporal(
    immer((set) => ({
      resume: {} as ResumeDto,
      setValue: (path, value) => {
        set((state) => {
          if (path === "visibility") {
            // Type guard for visibility enum
            if (value === "public" || value === "private") {
              state.resume.visibility = value;
            } else {
              console.warn(`Invalid visibility value: ${value}. Expected "public" or "private".`);
            }
          } else {
            // Use lodash.set for nested paths (type safety is handled by ResumeValue type)
            state.resume.data = _set(state.resume.data, path, value) as typeof state.resume.data;
          }

          void debouncedUpdateResume(JSON.parse(JSON.stringify(state.resume)));
        });
      },
      addSection: () => {
        const section: CustomSectionGroup = {
          ...defaultSection,
          id: createId(),
          name: t`Custom Section`,
          items: [],
        };

        set((state) => {
          const lastPageIndex = state.resume.data.metadata.layout.length - 1;
          state.resume.data.metadata.layout[lastPageIndex][0].push(`custom.${section.id}`);
          state.resume.data = _set(state.resume.data, `sections.custom.${section.id}`, section);

          void debouncedUpdateResume(JSON.parse(JSON.stringify(state.resume)));
        });
      },
      removeSection: (sectionId: SectionKey) => {
        if (sectionId.startsWith("custom.")) {
          const id = sectionId.split("custom.")[1];

          set((state) => {
            removeItemInLayout(sectionId, state.resume.data.metadata.layout);
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete state.resume.data.sections.custom[id];

            void debouncedUpdateResume(JSON.parse(JSON.stringify(state.resume)));
          });
        }
      },
      collapsedSections: {},
      toggleCollapseSection: (id) => {
        set((state) => {
          // Ensure boolean type (handle undefined as false)
          const currentValue = state.collapsedSections[id] ?? false;
          state.collapsedSections[id] = !currentValue;
        });
      },
      expandAllSections: () => {
        set((state) => {
          state.collapsedSections = {};
        });
      },
      collapseAllSections: () => {
        set((state) => {
          const collapsed: Record<string, boolean> = { basics: true };
          for (const section of Object.keys(state.resume.data.sections)) {
            collapsed[section] = true;
          }
          // Add any custom sections to the collapsed state
          for (const section of Object.keys(state.resume.data.sections.custom)) {
            collapsed[`custom.${section}`] = true;
          }
          state.collapsedSections = collapsed;
        });
      },
    })),
    {
      limit: 100,
      wrapTemporal: (fn) => devtools(fn),
      partialize: ({ resume }) => ({ resume }),
    },
  ),
);

export const useTemporalResumeStore = <T>(
  selector: (state: TemporalState<Pick<ResumeStore, "resume">>) => T,
  equality?: (a: T, b: T) => boolean,
) => useStoreWithEqualityFn(useResumeStore.temporal, selector, equality);
